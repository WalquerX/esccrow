use near_sdk::{env, near_bindgen, AccountId, PanicOnDefault, Promise};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::BorshStorageKey;
use near_sdk::json_types::U128;
//use near_sdk::env::{account_balance, current_account_id};

const ONE_NEAR: u128 = 1_000_000_000_000_000_000_000_000; // 1 $NEAR as yoctoNEAR

/*******************************/
/*********** STRUCTS ***********/
/*******************************/
pub type TransactionId = u128; //********* 
pub type Price = u128;
pub type TokenId = String;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum TransactionStatus {
    Pending,
    Confirmed,
    Completed,
    Cancelled,
}

/// Helper structure for keys of the persistent collections.
/*
    Since all data stored on the blockchain is kept in a single key-value store under the contract account, 
    you must always use a unique storage prefix for different collections to avoid data collision. It is used in the initialization funct.
    https://near.github.io/near-sdk-as/classes/_sdk_core_assembly_collections_persistentmap_.persistentmap.html#constructor
*/
#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKeys {
    TransactionsPerAccount,
    SubAccount { account_hash: Vec<u8> },
    TransactionById,
    TransactionMetadataById,
}

//impl BorshIntoStorageKey for StorageKey {}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)] //why do we need serialize and deserialize?
#[serde(crate = "near_sdk::serde")]
pub struct Transaction {
    //transaction ID
    pub transaction_id: TransactionId,  //should be unique and generated by the contract
    //transaction creator ID
    pub creator_id: AccountId, //should be the current account
    //transaction seller ID
    pub seller_id: AccountId, 
    //transaction buyer ID
    pub buyer_id: AccountId, 
    //transaction price
    pub price: Price, 
    //token ID
    pub nft_id: TokenId,
    //token's contract ID
    pub nft_contract_id: AccountId,
    //price amount is in the contract custody or not
    pub amount_in_escrow: bool,
    //token is in the contract custody or not
    pub token_in_escrow: bool,
    //transaction is completed or not
    pub transaction_status: TransactionStatus,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TransactionMetadata {
    pub categories: String  //a placeholder for now, we may not need metadata at all 
}

/*******************************/
/*******AUX FUNCTIONS **********/
/*******************************/

//used to generate a unique prefix in our storage collections (this is to avoid data collisions)
//pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
//    //get the default hash
//    let mut hash = CryptoHash::default();
//    //we hash the account ID and return it
//    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
//    hash
//}

/*******************************/
/*********** CONTRACT **********/
/*******************************/

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)] // panic on default to ensure that all fields are initialized
pub struct Contract {

    //total of transactions
    pub total_transactions: u128, // should it be a bigger number?

    //contract owner
    pub owner_id: AccountId,

    //keeps track of all the transactions IDs for a given account
    pub transactions_per_account: LookupMap<AccountId, UnorderedSet<TransactionId>>,

    //keeps track of the transaction struct for a given transaction ID
    pub transaction_by_id: LookupMap<TransactionId, Transaction>,

    //keeps track of the transaction metadata for a given transaction ID [info that doesnt change during transaction]
    pub transaction_metadata_by_id: UnorderedMap<TransactionId, TransactionMetadata>,
}

/*******************************/
/******* INITIALIZATION ********/
/*******************************/

#[near_bindgen]
impl Contract {
    /*
        initialization function (can only be called once).
        sets the contract owner
    */    
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        //create a variable of type Self with all the fields initialized. 
        Self {
            total_transactions: 0, //total number of transactions, used for id generation
            //set the owner_id field equal to the passed in owner_id. 
            owner_id,
            //Storage keys are simply the prefixes used for the collections. This helps avoid data collision
            transactions_per_account: LookupMap::new(StorageKeys::TransactionsPerAccount),
            transaction_by_id: LookupMap::new(StorageKeys::TransactionById),
            transaction_metadata_by_id: UnorderedMap::new(StorageKeys::TransactionMetadataById),
        }
    }

    pub fn add_transaction_to_user(& mut self, account_id: &AccountId, transaction_id: &TransactionId){ //make it private
        let mut transaction_set = self.transactions_per_account.get(account_id).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKeys::SubAccount { account_hash: env::sha256(account_id.as_bytes()) }
            )
        });
        transaction_set.insert(transaction_id);

        //we insert that set for the given account ID. 
        self.transactions_per_account.insert(account_id, &transaction_set);
    }

    //pub fn get_lookup_map(&self, key: &AccountId) -> UnorderedSet<TransactionId> {
    //    match self.transactions_per_account.get(key) {
    //        Some(set) => {
    //            let log_message = format!("Value from LookupMap is {:?}", value.clone());
    //            env::log(log_message.as_bytes());
    //            value
    //        },
    //        None => "not found".to_string()
    //    }
    //}

    pub fn transactions_per_account( &self, account_id: AccountId) -> U128 {

        let transaction_set = self.transactions_per_account.get(&account_id);

        if let Some(transaction_set) = transaction_set {
            U128(transaction_set.len() as u128)
        } else {
            U128(0)
        }
    }

    #[payable]
    pub fn create_transaction(       //implement storage management for transactions
        &mut self,
        seller_id: AccountId,
        buyer_id: AccountId,
        price: Price,
        nft_id: TokenId,
        nft_contract_id: AccountId,
        ) -> Transaction {

        let sender = env::predecessor_account_id();

        let transaction = Transaction {
            transaction_id: self.total_transactions,  //********** should be unique and generated by the contract
            creator_id: sender.clone(),
            seller_id: seller_id.clone(),
            buyer_id: buyer_id.clone(), 
            price: price,
            nft_id: nft_id.clone(),
            nft_contract_id: nft_contract_id.clone(),
            amount_in_escrow: false,
            token_in_escrow: false,
            transaction_status: TransactionStatus::Pending,
        };


        //let account_as_key = transaction.creator_id.try_to_vec().unwrap();

        // update number of transactions
        //self.total_transactions += 1;

        self.add_transaction_to_user(&transaction.creator_id, &transaction.transaction_id);
        
        self.transaction_by_id.insert(&transaction.transaction_id, &transaction);
       
        transaction
    }

    pub fn get_transaction_by_id(&self, transaction_id: TransactionId) -> Transaction {
        self.transaction_by_id.get(&transaction_id).unwrap_or_else(|| {
            panic!("Transaction not found")
        })
    }

    //pub fn transfer() -> Promise {  //should be private, and only be called under some conditions
    //    let amount = env::account_balance() - 20*ONE_NEAR;  // should be replace by the amount transfered
    //    Promise::new(receiver_id).transfer(amount)
    //}

    pub fn pay(receiver_id: AccountId) -> Promise {  //should be private, and only be called under some conditions, do i need &self? as argument
        let amount = env::account_balance() - 20*ONE_NEAR;  // should be replace by the amount transfered
        Promise::new(receiver_id).transfer(amount)
    }
}


